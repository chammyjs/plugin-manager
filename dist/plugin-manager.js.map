{"version":3,"file":"plugin-manager.js","sources":["../src/utils.js","../src/PluginManager.js"],"sourcesContent":["import glob from 'glob';\n\n/**\n * Check if given parameter is a string.\n *\n * @private\n * @param {mixed} value Value to be checked.\n * @returns {boolean} Return true if passed value is a string,\n * false otherwise.\n */\nfunction isString( value ) {\n\treturn typeof value === 'string';\n}\n\n/**\n * Wrap glob invocation into {@link Promise}.\n *\n * @private\n * @param {string} pattern Glob pattern.\n * @param {string} path Path, in which search should begin.\n * @returns {Promise<string[],Error>} Promise resolving to found\n * file paths.\n */\nfunction makeGlobPromise( pattern, path ) {\n\treturn new Promise( ( resolve, reject ) => {\n\t\tglob( pattern, {\n\t\t\tcwd: path,\n\t\t\tabsolute: true\n\t\t}, ( err, files ) => {\n\t\t\tif ( err ) {\n\t\t\t\treject( err );\n\t\t\t}\n\n\t\t\tresolve( files );\n\t\t} );\n\t} );\n}\n\nexport { isString };\nexport { makeGlobPromise };\n","/**\n * @external {Plugin} https://github.com/chammyjs/plugin-helper\n */\n\nimport { Plugin } from '@chammy/plugin-helper';\nimport { isString } from './utils.js';\nimport { makeGlobPromise } from './utils.js';\n\n/**\n * Simple plugin manager for Chammy.js.\n * It's responsible for finding and loading plugins.\n */\nclass PluginManager {\n\tconstructor() {\n\t\t/**\n\t\t * Iterable set of all loaded plugins.\n\t\t *\n\t\t * @type {Set<Plugin>}\n\t\t */\n\t\tthis.plugins = new Set();\n\t}\n\n\t/**\n\t * Find packages matching the given names.\n\t *\n\t * @param {string|string[]} patterns Glob patterns.\n\t * @param {string} path Path in which the search will be done.\n\t * @throws {TypeError}\n\t * @returns {Promise<string[],Error>} Promise resolving to array of paths.\n\t */\n\tfind( patterns, path = process.cwd() ) {\n\t\tif ( !isString( patterns ) && ( !Array.isArray( patterns ) || !patterns.every( isString ) ) ) {\n\t\t\tthrow new TypeError( 'pattern parameter must be a string or an array of strings' );\n\t\t}\n\n\t\tif ( !isString( path ) ) {\n\t\t\tthrow new TypeError( 'path parameter must be a string' );\n\t\t}\n\n\t\tif ( isString ( patterns ) ) {\n\t\t\tpatterns = [ patterns ];\n\t\t}\n\n\t\tconst promises = patterns.map( ( pattern ) => {\n\t\t\treturn makeGlobPromise( pattern, path );\n\t\t} );\n\n\t\treturn Promise.all( promises ).then( ( result ) => {\n\t\t\treturn result.reduce( ( all, current ) => {\n\t\t\t\treturn all.concat( current );\n\t\t\t}, [] );\n\t\t} );\n\t}\n\n\t/**\n\t * Load given plugins.\n\t *\n\t * @param {string[]} plugins Names of plugins to load.\n\t * @throws {TypeError}\n\t * @returns {Promise<Plugin[],TypeError>} Promise resolving to array of plugin classes.\n\t */\n\tload( plugins ) {\n\t\tif ( !Array.isArray( plugins ) || !plugins.every( isString ) ) {\n\t\t\tthrow new TypeError( 'Parameter must be an array of strings' );\n\t\t}\n\n\t\tconst loaded = plugins.map( ( plugin ) => {\n\t\t\tconst module = require( plugin );\n\n\t\t\tif ( Reflect.getPrototypeOf( module ) !== Plugin ) {\n\t\t\t\treturn Promise.reject( new TypeError( 'Plugins must extend Plugin class' ) );\n\t\t\t}\n\n\t\t\tthis.plugins.add( module );\n\n\t\t\treturn module;\n\t\t} );\n\n\t\treturn Promise.all( loaded );\n\t}\n\n\t/**\n\t * Find packages matching given patterns and load them.\n\t *\n\t * @param {string|string[]} patterns Glob patterns.\n\t * @param {string} path Path in which the search will be done.\n\t * @returns {Promise<Plugin[],TypeError>} Promise resolving to array of plugin classes.\n\t */\n\tfindAndLoad( patterns, path = process.cwd() ) {\n\t\treturn this.find( patterns, path ).then( ( paths ) => {\n\t\t\treturn this.load( paths );\n\t\t} );\n\t}\n\n\t/**\n\t * Allows to iterate over all plugins loaded by given\n\t * PluginManager instance.\n\t *\n\t * @returns {Iterator} Iterator for {@link PluginManager#plugins} property.\n\t */\n\t[ Symbol.iterator ]() {\n\t\treturn this.plugins[ Symbol.iterator ]();\n\t}\n}\n\nexport default PluginManager;\n"],"names":["isString","makeGlobPromise","Promise","PluginManager","plugins","Set","path","process","cwd","Array","isArray","patterns","every","TypeError","promises","map","all","then","result","reduce","concat","loaded","module","require","Reflect","getPrototypeOf","Plugin","add","reject","find","load","Symbol","iterator"],"mappings":"iRAUA,QAASA,SAAT,GAA2B,OACF,QAAjB,WAYR,QAASC,gBAAT,KAA0C,OAClC,IAAIC,QAAJ,CAAa,aAAuB,QAC3B,MAAA,YAAA,EAGZ,aAAkB,QAAA,KAHrB,EADM,CAAA,82CCZFC,uCACS,uBAAA,MAMRC,QAAU,GAAIC,wDAWmB,IAAvBC,0DAAOC,QAAQC,GAARD,MACjB,CAACP,WAAD,GAA2B,CAACS,MAAMC,OAAND,GAAD,EAA8B,CAACE,EAASC,KAATD,CAAgBX,QAAhBW,CAA1D,OACE,IAAIE,UAAJ,CAAe,2DAAf,KAGF,CAACb,iBACC,IAAIa,UAAJ,CAAe,iCAAf,EAGFb,WATiC,KAU1B,GAV0B,KAahCc,GAAWH,EAASI,GAATJ,CAAc,WAAe,OACtCV,qBADS,CAAAU,QAIVT,SAAQc,GAARd,IAAwBe,IAAxBf,CAA8B,WAAc,OAC3CgB,GAAOC,MAAPD,CAAe,aAAoB,OAClCF,GAAII,MAAJJ,GADD,CAAAE,IADD,CAAAhB,iCAcQ,eACV,CAACO,MAAMC,OAAND,GAAD,EAA6B,CAACL,EAAQQ,KAARR,CAAeJ,QAAfI,OAC5B,IAAIS,UAAJ,CAAe,uCAAf,KAGDQ,GAASjB,EAAQW,GAARX,CAAa,WAAc,IACnCkB,GAASC,WAD0B,MAGpCC,SAAQC,cAARD,MAAqCE,mBAHD,IAOpCtB,QAAQuB,MAP4B,IAIjCzB,QAAQ0B,MAAR1B,CAAgB,GAAIW,UAAJ,CAAe,kCAAf,CAAhBX,CAJM,CAAAE,QAYRF,SAAQc,GAARd,0CAUsC,YAAvBI,yDAAOC,QAAQC,GAARD,SACtB,MAAKsB,IAAL,MAA4BZ,IAA5B,CAAkC,WAAa,OAC9C,GAAKa,IAAL,GADD,CAAA,SAWNC,OAAOC,yBAAa,OACd,MAAK5B,OAAL,CAAc2B,OAAOC,QAArB"}