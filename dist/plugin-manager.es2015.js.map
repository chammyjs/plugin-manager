{"version":3,"file":"plugin-manager.es2015.js","sources":["../src/utils.js","../src/PluginManager.js"],"sourcesContent":["import glob from 'glob';\n\n/**\n * Check if given parameter is a string.\n *\n * @private\n * @param {mixed} value Value to be checked.\n * @returns {boolean} Return true if passed value is a string,\n * false otherwise.\n */\nfunction isString( value ) {\n\treturn typeof value === 'string';\n}\n\n/**\n * Wrap glob invocation into {@link Promise}.\n *\n * @private\n * @param {string} pattern Glob pattern.\n * @param {string} path Path, in which search should begin.\n * @returns {Promise<string[],Error>} Promise resolving to found\n * file paths.\n */\nfunction makeGlobPromise( pattern, path ) {\n\treturn new Promise( ( resolve, reject ) => {\n\t\tglob( pattern, {\n\t\t\tcwd: path,\n\t\t\tabsolute: true\n\t\t}, ( err, files ) => {\n\t\t\tif ( err ) {\n\t\t\t\treject( err );\n\t\t\t}\n\n\t\t\tresolve( files );\n\t\t} );\n\t} );\n}\n\nexport { isString };\nexport { makeGlobPromise };\n","/**\n * @external {Plugin} https://github.com/chammyjs/plugin-helper\n */\n\nimport { Plugin } from '@chammy/plugin-helper';\nimport { isString } from './utils.js';\nimport { makeGlobPromise } from './utils.js';\n\n/**\n * Simple plugin manager for Chammy.js.\n * It's responsible for finding and loading plugins.\n */\nclass PluginManager {\n\tconstructor() {\n\t\t/**\n\t\t * Iterable set of all loaded plugins.\n\t\t *\n\t\t * @type {Set<Plugin>}\n\t\t */\n\t\tthis.plugins = new Set();\n\t}\n\n\t/**\n\t * Find packages matching the given names.\n\t *\n\t * @param {string|string[]} patterns Glob patterns.\n\t * @param {string} path Path in which the search will be done.\n\t * @throws {TypeError}\n\t * @returns {Promise<string[],Error>} Promise resolving to array of paths.\n\t */\n\tfind( patterns, path = process.cwd() ) {\n\t\tif ( !isString( patterns ) && ( !Array.isArray( patterns ) || !patterns.every( isString ) ) ) {\n\t\t\tthrow new TypeError( 'pattern parameter must be a string or an array of strings' );\n\t\t}\n\n\t\tif ( !isString( path ) ) {\n\t\t\tthrow new TypeError( 'path parameter must be a string' );\n\t\t}\n\n\t\tif ( isString ( patterns ) ) {\n\t\t\tpatterns = [ patterns ];\n\t\t}\n\n\t\tconst promises = patterns.map( ( pattern ) => {\n\t\t\treturn makeGlobPromise( pattern, path );\n\t\t} );\n\n\t\treturn Promise.all( promises ).then( ( result ) => {\n\t\t\treturn result.reduce( ( all, current ) => {\n\t\t\t\treturn all.concat( current );\n\t\t\t}, [] );\n\t\t} );\n\t}\n\n\t/**\n\t * Load given plugins.\n\t *\n\t * @param {string[]} plugins Names of plugins to load.\n\t * @throws {TypeError}\n\t * @returns {Promise<Plugin[],TypeError>} Promise resolving to array of plugin classes.\n\t */\n\tload( plugins ) {\n\t\tif ( !Array.isArray( plugins ) || !plugins.every( isString ) ) {\n\t\t\tthrow new TypeError( 'Parameter must be an array of strings' );\n\t\t}\n\n\t\tconst loaded = plugins.map( ( plugin ) => {\n\t\t\tconst module = require( plugin );\n\n\t\t\tif ( Reflect.getPrototypeOf( module ) !== Plugin ) {\n\t\t\t\treturn Promise.reject( new TypeError( 'Plugins must extend Plugin class' ) );\n\t\t\t}\n\n\t\t\tthis.plugins.add( module );\n\n\t\t\treturn module;\n\t\t} );\n\n\t\treturn Promise.all( loaded );\n\t}\n\n\t/**\n\t * Find packages matching given patterns and load them.\n\t *\n\t * @param {string|string[]} patterns Glob patterns.\n\t * @param {string} path Path in which the search will be done.\n\t * @returns {Promise<Plugin[],TypeError>} Promise resolving to array of plugin classes.\n\t */\n\tfindAndLoad( patterns, path = process.cwd() ) {\n\t\treturn this.find( patterns, path ).then( ( paths ) => {\n\t\t\treturn this.load( paths );\n\t\t} );\n\t}\n\n\t/**\n\t * Allows to iterate over all plugins loaded by given\n\t * PluginManager instance.\n\t *\n\t * @returns {Iterator} Iterator for {@link PluginManager#plugins} property.\n\t */\n\t[ Symbol.iterator ]() {\n\t\treturn this.plugins[ Symbol.iterator ]();\n\t}\n}\n\nexport default PluginManager;\n"],"names":["isString","makeGlobPromise","Promise","glob","cwd","absolute","PluginManager","constructor","plugins","Set","find","process","Array","isArray","every","TypeError","map","all","then","reduce","concat","load","require","Reflect","getPrototypeOf","Plugin","add","reject","findAndLoad","Symbol","iterator"],"mappings":"sJAUA,QAASA,SAAT,GAA2B,CAC1B,MAAwB,QAAjB,UACP,CAWD,QAASC,gBAAT,KAA0C,CACzC,MAAO,IAAIC,QAAJ,CAAa,OAAuB,CAC1CC,OAAe,CACdC,KADc,CAEdC,WAFc,CAAf,CAGG,OAAkB,IAEnB,IAFmB,CAKpB,IACA,CATD,CAUA,CAXM,CAYP,CCxBD,KAAMC,gBAAc,CACnBC,aAAc,CAMb,KAAKC,OAAL,CAAe,GAAIC,IACnB,CAUDC,OAAgB,EAAOC,QAAQP,GAAR,EAAvB,CAAuC,CACtC,GAAK,CAACJ,WAAD,GAA2B,CAACY,MAAMC,OAAN,GAAD,EAA8B,CAAC,EAASC,KAAT,CAAgBd,QAAhB,CAA1D,CAAL,CACC,KAAM,IAAIe,UAAJ,CAAe,2DAAf,CAAN,CAGD,GAAK,CAACf,WAAN,CACC,KAAM,IAAIe,UAAJ,CAAe,iCAAf,CAAN,CAGIf,WATiC,GAUrC,EAAW,GAV0B,EAatC,KAAM,GAAW,EAASgB,GAAT,CAAc,KACvBf,oBADS,CAAjB,CAIA,MAAOC,SAAQe,GAAR,IAAwBC,IAAxB,CAA8B,KAC7B,EAAOC,MAAP,CAAe,OACd,EAAIC,MAAJ,GADD,IADD,CAKP,CASDC,OAAgB,CACf,GAAK,CAACT,MAAMC,OAAN,GAAD,EAA6B,CAAC,EAAQC,KAAR,CAAed,QAAf,CAAnC,CACC,KAAM,IAAIe,UAAJ,CAAe,uCAAf,CAAN,CAGD,KAAM,GAAS,EAAQC,GAAR,CAAa,KAAc,CACzC,KAAM,GAASM,UAAf,CADyC,MAGpCC,SAAQC,cAAR,MAAqCC,MAHD,EAOzC,KAAKjB,OAAL,CAAakB,GAAb,GAPyC,IAIjCxB,QAAQyB,MAAR,CAAgB,GAAIZ,UAAJ,CAAe,kCAAf,CAAhB,CAMR,CAVc,CAAf,CAYA,MAAOb,SAAQe,GAAR,GACP,CASDW,cAAuB,EAAOjB,QAAQP,GAAR,EAA9B,CAA8C,CAC7C,MAAO,MAAKM,IAAL,MAA4BQ,IAA5B,CAAkC,KACjC,KAAKG,IAAL,GADD,CAGP,CAQD,CAAEQ,OAAOC,QAAT,GAAsB,CACrB,MAAO,MAAKtB,OAAL,CAAcqB,OAAOC,QAArB,GACP,CA1FkB"}