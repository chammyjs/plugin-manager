/*! @chammy/plugin-manager v0.0.0 | (c) 2017 Chammy.js | MIT license (see LICENSE) */import{Plugin}from'@chammy/plugin-helper';import glob from'glob';function isString(a){return'string'==typeof a}function makeGlobPromise(a,b){return new Promise((c,d)=>{glob(a,{cwd:b,absolute:!0},(a,b)=>{a&&d(a),c(b)})})}class PluginManager$1{constructor(){this.plugins=new Set}find(a,b=process.cwd()){if(!isString(a)&&(!Array.isArray(a)||!a.every(isString)))throw new TypeError('pattern parameter must be a string or an array of strings');if(!isString(b))throw new TypeError('path parameter must be a string');isString(a)&&(a=[a]);const c=a.map((a)=>makeGlobPromise(a,b));return Promise.all(c).then((a)=>a.reduce((a,b)=>a.concat(b),[]))}load(a){if(!Array.isArray(a)||!a.every(isString))throw new TypeError('Parameter must be an array of strings');const b=a.map((a)=>{const b=require(a);return Reflect.getPrototypeOf(b)===Plugin?(this.plugins.add(b),b):Promise.reject(new TypeError('Plugins must extend Plugin class'))});return Promise.all(b)}findAndLoad(a,b=process.cwd()){return this.find(a,b).then((a)=>this.load(a))}[Symbol.iterator](){return this.plugins[Symbol.iterator]()}}export default PluginManager$1;
//# sourceMappingURL=plugin-manager.es2015.js.map
